# >---------------------------------------------------------------------------<
#
#            _____       _ _   __          ___                  _
#           |  __ \     (_) |  \ \        / (_)                | |
#           | |__) |__ _ _| |___\ \  /\  / / _ ______ _ _ __ __| |
#           |  _  // _` | | / __|\ \/  \/ / | |_  / _` | '__/ _` |
#           | | \ \ (_| | | \__ \ \  /\  /  | |/ / (_| | | | (_| |
#           |_|  \_\__,_|_|_|___/  \/  \/   |_/___\__,_|_|  \__,_|
#
#   This template was generated by rails_apps_composer, a custom version of
#   RailsWizard, the application template builder. For more information, see:
#   https://github.com/RailsApps/rails_apps_composer/
#
# >---------------------------------------------------------------------------<

# >----------------------------[ Initial Setup ]------------------------------<

initializer 'generators.rb', <<-RUBY
Rails.application.config.generators do |g|
end
RUBY

@recipes = ["pg", "rspec_fg", "capistrano", "devel"]

def recipes; @recipes end
def recipe?(name); @recipes.include?(name) end

def say_custom(tag, text); say "\033[1m\033[36m" + tag.to_s.rjust(10) + "\033[0m" + "  #{text}" end
def say_recipe(name); say "\033[1m\033[36m" + "recipe".rjust(10) + "\033[0m" + "  Running #{name} recipe..." end
def say_wizard(text); say_custom(@current_recipe || 'wizard', text) end

def ask_wizard(question)
  ask "\033[1m\033[30m\033[46m" + (@current_recipe || "prompt").rjust(10) + "\033[0m\033[36m" + "  #{question}\033[0m"
end

def yes_wizard?(question)
  answer = ask_wizard(question + " \033[33m(y/n)\033[0m")
  case answer.downcase
    when "yes", "y"
      true
    when "no", "n"
      false
    else
      yes_wizard?(question)
  end
end

def no_wizard?(question); !yes_wizard?(question) end

def multiple_choice(question, choices)
  say_custom('question', question)
  values = {}
  choices.each_with_index do |choice,i| 
    values[(i + 1).to_s] = choice[1]
    say_custom (i + 1).to_s + ')', choice[0]
  end
  answer = ask_wizard("Enter your selection:") while !values.keys.include?(answer)
  values[answer]
end

@current_recipe = nil
@configs = {}

@after_blocks = []
def after_bundler(&block); @after_blocks << [@current_recipe, block]; end
@after_everything_blocks = []
def after_everything(&block); @after_everything_blocks << [@current_recipe, block]; end
@before_configs = {}
def before_config(&block); @before_configs[@current_recipe] = block; end


# this application template only supports Rails version 3.1 and newer
case Rails::VERSION::MAJOR.to_s
when "3"
  case Rails::VERSION::MINOR.to_s
  when "2"
    say_wizard "You are using Rails version #{Rails::VERSION::STRING}."
  when "1"
    say_wizard "You are using Rails version #{Rails::VERSION::STRING}."
  when "0"
    say_wizard "You are using Rails version #{Rails::VERSION::STRING} which is not supported. Try 3.1 or newer."
    raise StandardError.new "Rails #{Rails::VERSION::STRING} is not supported. Try 3.1 or newer."
  else
    say_wizard "You are using Rails version #{Rails::VERSION::STRING}."
  end
else
  say_wizard "You are using Rails version #{Rails::VERSION::STRING} which is not supported. Try 3.1 or newer."
  raise StandardError.new "Rails #{Rails::VERSION::STRING} is not supported. Try 3.1 or newer."
end

say_wizard "Checking configuration. Please confirm your preferences."

# >---------------------------[ Autoload Modules/Classes ]-----------------------------<

inject_into_file 'config/application.rb', :after => 'config.autoload_paths += %W(#{config.root}/extras)' do <<-'RUBY'

    config.autoload_paths += %W(#{config.root}/lib)
RUBY
end

# >---------------------------------[ Recipes ]----------------------------------<


# >----------------------------------[ Pg ]-----------------------------------<

@current_recipe = "pg"
@before_configs["pg"].call if @before_configs["pg"]
say_recipe 'Pg'


@configs[@current_recipe] = config

gsub_file 'Gemfile', "gem 'sqlite3'\n", ""

gem "pg"

after_bundler do
  say_wizard "Pg recipe running 'after_bundler'"
  remove_file 'db/development.sqlite3'
  remove_file 'config/database.yml'
  create_file 'config/database.yml' do
<<-YAML
standard: &standard
  encoding: utf8
  adapter: postgresql
  pool: 5
  timeout: 5000
  username: postgres
  password: postgres

development:
  <<: *standard
  database: #{app_name}_dev

test: &test
  <<: *standard
  database: #{app_name}_test
YAML
  end

end


# >-------------------------------[ RSpec_fg ]--------------------------------<

@current_recipe = "rspec_fg"
@before_configs["rspec_fg"].call if @before_configs["rspec_fg"]
say_recipe 'RSpec_fg'


@configs[@current_recipe] = config

gem 'rspec-rails', :group => [:development, :test]
gem 'factory_girl_rails', :group => [:development, :test]

# note: there is no need to specify the RSpec generator in the config/application.rb file

after_bundler do
  say_wizard "RSpec recipe running 'after bundler'"
  generate 'rspec:install'

  say_wizard "Include FactoryGirl syntax methods"
  inject_into_file 'spec/spec_helper.rb', :after => "RSpec.configure do |config|\n" do <<-RUBY

  config.include FactoryGirl::Syntax::Methods

RUBY
  end

  say_wizard "Create .rspec file"
  remove_file ".rspec"
  create_file ".rspec" do
<<-CONF
--colour
--format documentation
CONF
  end

  say_wizard "Create .travis.yml file"
  create_file ".travis.yml" do
<<-CONF
language: ruby
rvm:
  - 1.9.3
before_script:
  - psql -c 'create database #{app_name}_test' -U postgres
  - RAILS_ENV=test bundle exec rake db:migrate
script: 
  - bundle exec rspec spec
CONF
  end

  say_wizard "Removing test folder (not needed for RSpec)"
  run 'rm -rf test/'

  inject_into_file 'config/application.rb', :after => "Rails::Application\n" do <<-RUBY

    # don't generate RSpec tests for views and helpers
    config.generators do |g|
      g.view_specs false
      g.helper_specs false
    end

RUBY
  end
end


# >------------------------------[ Capistrano ]-------------------------------<

@current_recipe = "capistrano"
@before_configs["capistrano"].call if @before_configs["capistrano"]
say_recipe 'Capistrano'


@configs[@current_recipe] = config

gem 'capistrano', :group => [:development]
gem 'capistrano-ext', :group => [:development]
gem 'brightbox', :group => [:development]

after_bundler do
  say_wizard "Capistrano recipe running 'after bundler'"
  run 'capify .'
  remove_file 'config/deploy.rb'
  create_file 'config/deploy.rb' do
<<-DEPLOY
set :default_stage, 'staging'
require 'capistrano/ext/multistage'
gem 'brightbox', '>=2.3.9'
require 'brightbox/recipes'
require 'brightbox/passenger'

set :application, "#{app_name}"

set(:deploy_to) { File.join("", "home", user, application) }

set :repository,  "git@github.com:unepwcmc/#{app_name}.git"
set :scm, :git
set :scm_username, "unepwcmc-read"
set :deploy_via, :remote_cache

set :local_shared_files, %w(config/database.yml)

default_run_options[:pty] = true

task :setup_production_database_configuration do
  the_host = Capistrano::CLI.ui.ask("Database IP address: ")
  database_name = Capistrano::CLI.ui.ask("Database name: ")
  database_user = Capistrano::CLI.ui.ask("Database username: ")
  pg_password = Capistrano::CLI.password_prompt("Database user password: ")

  require 'yaml'

  spec = {
    "#\{rails_env\}" => {
      "adapter" => "postgresql",
      "database" => database_name,
      "username" => database_user,
      "host" => the_host,
      "password" => pg_password
    }
  }

  run "mkdir -p #\{shared_path\}/config"
  put(spec.to_yaml, "#\{shared_path\}/config/database.yml")
end
after "deploy:setup", :setup_production_database_configuration

DEPLOY
  end

  create_file "config/deploy/staging.rb" do
    'set :rails_env, "staging"'
  end
  create_file "config/deploy/production.rb" do
    'set :rails_env, "production"'
  end

end


# >---------------------------------[ Devel ]---------------------------------<

@current_recipe = "devel"
@before_configs["devel"].call if @before_configs["devel"]
say_recipe 'Devel'


@configs[@current_recipe] = config

gem 'ruby-debug19', :group => [:development]

after_bundler do
  say_wizard "Devel recipe running 'after bundler'"
  say_wizard "Create .gitignore"
  remove_file '.gitignore'
  create_file 'gitignore.rb' do
<<-GITIGNORE
# Ignore bundler config
/.bundle

# Ignore all logfiles and tempfiles.
/rdoc
/log/*.log
/tmp
/public/system

# Ruby
/vendor/ruby

# VIM
*.swp
*.un~

# OS X
*.DS_Store

# Netbeans and other IDEâ€™s
/nbproject
.project
.idea/
GITIGNORE
  end

  say_wizard "Create README.md"
  remove_file "README.rdoc"
  create_file "README.md" do
    <<-README
##{app_name} [![Build Status](https://secure.travis-ci.org/unepwcmc/SAPI.png?branch=master)](http://travis-ci.org/unepwcmc/#{app_name})
This is the generic README of the #{app_name} project. Watch out for some awesomeness to come.

##Dependencies
##Installation
##Usage
    README
  end

end





@current_recipe = nil

# >-----------------------------[ Run Bundler ]-------------------------------<

say_wizard "Running 'bundle install'. This will take a while."
run 'bundle install'
run 'bundle update'
say_wizard "Running 'after bundler' callbacks."
require 'bundler/setup'
@after_blocks.each{|b| config = @configs[b[0]] || {}; @current_recipe = b[0]; b[1].call}

@current_recipe = nil
say_wizard "Running 'after everything' callbacks."
@after_everything_blocks.each{|b| config = @configs[b[0]] || {}; @current_recipe = b[0]; b[1].call}

@current_recipe = nil
say_wizard "Finished running the rails_apps_composer app template."
say_wizard "Your new Rails app is ready."
